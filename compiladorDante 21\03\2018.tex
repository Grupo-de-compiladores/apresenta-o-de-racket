\documentclass{beamer}

\usetheme[
  outer/progressbar=frametitle
]{metropolis}

\usepackage[portuguese]{babel}
\usepackage[utf8]{inputenc}

\hypersetup{colorlinks=true,urlcolor=blue,linkcolor=blue,citecolor=blue}

\title[Compiladores 2018.1]{1$^{a.}$ Apresentação do compilador Dante}
\author[Abrev.]{Autores: João Pedro Abreu, Luis Freitas e Raphael Leardini} 

\institute[UFF]{Universidade Federal Fluminense}

\date{Data: 21/03/2018} 

\begin{document}

% ---

\begin{frame}[plain]

\titlepage

\end{frame}

% ---

\begin{frame}{Linguagem escolhida: Racket}
A linguagem Racket é uma linguagem derivada de LISP(List Processer) criada em 1994 com o nome de PLT SCHEME e mudou de nome em 2010.
\end{frame}

% ---

\begin{frame}{Paradigmas}
A linguagem Racket é multiparadigmada.

Seus paradigmas são: Funcional, Procedural, Modular, Orientada a Objeto, Lógica, Reflexiva e Meta.

\end{frame}

% ---

\begin{frame}{Instalação - Sistemas UNIX}
A instalação da linguagem é bem simples em sistemas UNIX, só se deve ir no site da linguagem Racket, baixar o arquivo em shell script que lá se encontra e mandar executar.

Com isso se instala o compilador da linguagem, a linguagem em si e a IDE DrRacket que é a IDE recomendada pelos criadores.



\end{frame}

%---

\begin{frame}{Instalação - Sistemas Windows}
Para sistemas Windows a instalação funciona da mesma forma, inclusive possui o DrRacket embutido da mesma forma. Vale ressaltar que o próprio site detecta, na hora do download, o tipo de Sistema Operacional que está acessando a página.

\end{frame}

% ---

\begin{frame}{Exemplo de códigos}
Nessa parte vamos mostrar exemplo de códigos e explicaremos como a maioria deles funciona.
Todos os códigos foram feitos na IDE recomendada pelos criadores da linguagem o DrRacket.
\end{frame}
% ---

\begin{frame}{Hello World}
\#lang racket

"Hello, World!"
\end{frame}

% ---

\begin{frame}{Triangulo de Sierpinski}
\#lang racket

(require 2htdp/image)

(let sierpinski ([n 8])

  (if (zero? n)
  
    (triangle 2 'solid 'red)
    
    (let ([t (sierpinski (- n 1))])
    
      (freeze (above t (beside t t))))))


\end{frame}

% ---

\begin{frame}{Criação de Lista}
\#lang racket

(cons 1 2)

(car (cons 1 2))

(cdr(cons 1 2))
        
\end{frame}

%---

\begin{frame}{Definição de Structs}

\#lang racket

(struct dog (name breed age))

(define my-pet

  (dog "lassie" " "collie" 5))
  
resultado de (dog? my-pet) é true que é escrito como \#t

resultado de (dog-name my-pet) é lassie
  

\end{frame}
% ---
\begin{frame}{Vetores}
\#lang racket

\#(1 2 3) cria o vetor (1 2 3)

(vector-append \#(1 2 3) \#(4 5 6)) concatena vetores formando assim (1 2 3 4 5 6)

(list-\textgreater set '(1 2 3 1 2 3 3 2 1 3 2 1)) resulta num vetor de todos os elementos desse conjunto logo (1 2 3)


\end{frame}
%---
\begin{frame}{Repetição}

\#lang racket

(for ([i 10])

  Codigo desejado )
  
(for ([i (in-range 5 10)])

  codigo desejado)
    

\end{frame}
% ---


\begin{frame}{Orientação a Objeto}
(define fish\%

  (class object\%
  
    (init size) 
    
    (super-new) Essa aqui é a Super classe
    
    (define current-size size)
    
    (define/public (get-size)
    
      current-size)
      
    (define/public (grow amt)
    
      (set! current-size (+ amt current-size)))
      
    (define/public (eat other-fish)
    
      (grow (send other-fish get-size)))))


\end{frame}

%---

\begin{frame}[fragile]{Pattern Matching}
%\begin{verbatim}
Pattern Matching
(match '(1 2 3)

[(list a a a) (list a)]

[(list a b b) (list b a a)]

[(list "abc") (list "cba")]

[(list a b c) "ola"]) retorna "ola"

(match "algumaConstrucao" ["algumaConstrucao" "b"] ["algumaConstrucao" 

"a"]) retorna "b"

(struct tree (val right left))

(match (tree (10 'right 'left)) [(tree a \_ \_) (+ 1 a)]) retorna 11

(match "apple" [(regexp \#rx"p+") \#t] [\_ \#f])  retorna \#t
%\end{verbatim}
\end{frame}

%---

\begin{frame}[fragile]{Suporte à construção de compiladores}

O Racket é uma linguagem de programação de uso geral com um grande foco na criação de outras linguagens, dessa forma, possuindo vários mecanismos que favorecem e facilitam o uso dele como um compilador. 
Além de possuir um site muito bem estruturado e com ótimo auxilio a novos usuários.

\end{frame}

% ---

\begin{frame}[fragile]{Suporte à construção de compiladores}

Ele também possui:
 
- Documentação detalhada, de fácil acesso.

- Diversos exemplos de código e de linguagens criadas a partir dele.

- Uma biblioteca própria para PEG.

- Portabilidade: programas desenvolvidos em Windows, Linux ou macOS funcionarão nos três tipos de Sistema sem problemas.

- Fácil de instalar.

- DrRacket: uma IDE própria, que vem junto com o compilador base, altamente recomendada pelos criadores da linguagem.


\end{frame}



\begin{frame}{PEG}
PEG é uma solução para reconhecimento de linguagens, situada entre o poder das regex(expressões regulares) e a complexidade das GLC(gramaticas livre de 
contexto). 

Ela, ao invés de não-determinismo, se utiliza de noções de precedência nas regras para escolher uma derivação.

PEG é suportado nativamente pelo Racket, requerendo apenas o uso de (require peg/peg) no começo do arquivo.

\end{frame}

% ---

\begin{frame}{PEG}
PEG no racket pode ser visto como um avanço das regex, permitindo atribuir nomes a partes da string casada com a PEG para posterior tratamento.

Define-se uma regra Peg da seguinte forma :

\textbf{(define-peg nomeDaRegra padrão ação)}

Onde  \textbf{padrão} é uma Peg, representada como uma S-expressão apropriada e  \textbf{ação} é qualquer expressão válida em Racket, podendo ser um valor inteiro, uma lista, uma função aplicada a algum argumento, etc.

\end{frame}

% ---

\begin{frame}{PEG}
Nessa parte iremos mostrar alguns usos da biblioteca PEG e explicaremos um pouco sobre a maioria.
Todos os códigos foram feitos na IDE recomendada pelos criadores da linguagem o DrRacket.
\end{frame}
% ---


% --- possivelmente falar de regex, provavelmente não


% ---

\begin{frame}[fragile]{PEG}
\begin{verbatim}

(require peg/peg)
(define-peg number
(name value (+ (range #\0 #\9)))
(string->number value))
(define-peg prod
(and (name v1 number) (? (and #\* (name v2 prod))))
(if v2 (* v1 v2) v1))
(define-peg expr
(and (name term1 prod) (? (and #\+ (name term2 expr))) )
(if term2 (+ term1 term2) term1))
 (peg expr "2+4*7+6*5")     retorna 60
\end{verbatim}
\end{frame}

% ---


\begin{frame}[fragile]{PEG}

PEG

(require peg/peg)

(define-peg number

            (name value (+ (range \# $\backslash$0 \#$\backslash$9)))
            
            (string $\longrightarrow$ number value))
            
(define-peg var

            (and (or (range \#$\backslash$a \#$\backslash$z) (range \#$\backslash$A \#$\backslash$Z)) (* (any-char))))
            

(define-peg atribuicao

            (and (name variable var) "=" (name value number)) value)
            
(peg atribuicao "umInteiro=345") retorna 345

\end{frame}

% ---


\begin{frame}[fragile]{PEG}
\begin{verbatim}

(require peg/peg)
(struct soma (a b))
(struct prod (c d))
(define-peg number
(name value (+ (range #\0 #\9)))
(string- >number value))
(define-peg prod
(and (name v1 number) (? (and #\* (name v2 prod))))
(if v2 (prod v1 v2) v1))
(define-peg expr
(and (name term1 prod) (? (and #\+ (name term2 expr))) )

\end{verbatim}
\end{frame}

% ---

\begin{frame}[fragile]{PEG}
\begin{verbatim}


(if term2 (soma term1 term2) term1))
(soma? (peg expr "2+4*7+6*5"))     retorna #t
(soma-a (peg expr "2+4*7+6*5"))    retorna 2
(soma-b (peg expr "2+4*7+6*5"))    retorna #<soma>
(soma-a (soma-b (peg expr "2+4*7+6*5"))) retorna #<prod>
(prod-c (soma-a (soma-b (peg expr "2+4*7+6*5"))))retorna 4
\end{verbatim}
\end{frame}

% ---

\begin{frame}{Prós}

1) Ela tende a ser inteligível para usuários que já tem conhecimento sobre LISP, além de utilizar comandos familiares (ou até mesmo iguais) para compilação.

2) Ela é de fácil instalação, vindo com IDE inclusa.

3) É uma linguagem livre e por isso facilmente modificável.

4) Tem amplo suporte dos Desenvolvedores e do site, que é muito bem estruturado.

5) Ótima para desenvolvimento de outras linguagens e compiladores por ter uma biblioteca PEG embutida.


\end{frame}
\begin{frame}{Contras}

1) A falta de chaves pode deixar o código confuso.

2) Completamente diferente de linguagens mais "tradicionais" nas operações mais básicas.


\end{frame}
\end{document}
