\documentclass{beamer}

\usetheme[
  outer/progressbar=frametitle
]{metropolis}

\usepackage[portuguese]{babel}
\usepackage[utf8]{inputenc}

\hypersetup{colorlinks=true,urlcolor=blue,linkcolor=blue,citecolor=blue}

\title[Compiladores 2018.1]{1$^{a.}$ Apresentação do compilador Dante}
\author[Abrev.]{Autores: João Pedro Abreu, Luis Freitas e Raphael Leardini} 

\institute[UFF]{Universidade Federal Fluminense}

\date{Data: 21/03/2018} 

\begin{document}

% ---

\begin{frame}[plain]

\titlepage

\end{frame}

% ---

\begin{frame}{Linguagem escolhida: Racket}
A linguagem \textit{Racket} é uma linguagem derivada de \textit{LISP(List Processer)} criada em 1994 com o nome de \textit{PLT SCHEME} e mudou de nome em 2010.
\end{frame}

% ---

\begin{frame}{Paradigmas}
A linguagem \textit{Racket} é multiparadigmada.

Seus paradigmas são: Funcional, Procedural, Modular, Orientada a Objeto, Lógica, Reflexiva e Meta.

\end{frame}

% ---

\begin{frame}{Instalação}
A instalação da linguagem é bem simples em sistemas \textit{UNIX}, só se deve ir no site da linguagem \textit{Racket}, baixar o arquivo em \textit{shell script} que lá se encontra e mandar executar.

Com isso se instala o compilador da linguagem, a linguagem em si e a IDE \textit{DrRacket} que é a IDE recomendada pelos criadores.



\end{frame}

%---

\begin{frame}{Instalação}
Para sistemas \textit{Windows} a instalação funciona da mesma forma, inclusive também possui o \textit{DrRacket} embutido. Vale ressaltar que o próprio site detecta, na hora do download, o tipo de Sistema Operacional que está acessando a página.

\end{frame}

% ---

\begin{frame}{Exemplo de códigos}
Nessa parte vamos mostrar exemplo de códigos e explicaremos como a maioria deles funciona
Todas os códigos foram feitos na IDE recomendada pelos criadores da linguagem o \textit{DrRacket}.
\end{frame}
% ---

\begin{frame}{Hello World}
\#lang racket

"Hello, World!"
\end{frame}

% ---

\begin{frame}{Triangulo de Sierpinski}
\#lang racket

(require 2htdp/image)

(let sierpinski ([n 8])

  (if (zero? n)
  
    (triangle 2 'solid 'red)
    
    (let ([t (sierpinski (- n 1))])
    
      (freeze (above t (beside t t))))))


\end{frame}

% ---

\begin{frame}{Criação de Lista}
\#lang racket

(cons 1 2)

(car (cons 1 2))

(cdr(cons 1 2))
        
\end{frame}

%---

\begin{frame}{Definição de Structs}

\#lang racket

(struct dog (name breed age))

(define my-pet

  (dog "lassie" " "collie" 5))
  
resultado de (dog? my-pet) é true que é escrito como \#t

resultado de (dog-name my-pet) é lassie
  

\end{frame}
% ---
\begin{frame}{Vetores}
\#lang racket

\#(1 2 3) cria o vetor (1 2 3)

(vector-append \#(1 2 3) \#(4 5 6)) concatena vetores formando assim (1 2 3 4 5 6)

(list->set '(1 2 3 1 2 3 3 2 1 3 2 1)) resulta num vetor de todos os elementos desse conjunto logo (1 2 3)


\end{frame}
%---
\begin{frame}{Repetição}

\#lang racket

(for ([i 10])

  Codigo desejado )
  
(for ([i (in-range 5 10)])

  codigo desejado)
    
(loop 5)

\end{frame}
% ---


\begin{frame}{Orientação a Objeto}
(define fish\%

  (class object\%
  
    (init size) 
    
    (super-new) Essa aqui é a Super classe
    
    (define current-size size)
    
    (define/public (get-size)
    
      current-size)
      
    (define/public (grow amt)
    
      (set! current-size (+ amt current-size)))
      
    (define/public (eat other-fish)
    
      (grow (send other-fish get-size)))))


\end{frame}

% ---

\begin{frame}{Pattern Matching}
(match '(1 2 3) 
      [(list a a a) (list a)]
      [(list a b b) (list b a a)]
      [(list "abc") (list "cba")]
      [(list a b c) "ola"]) retorna "ola"
 (match "algumaConstrucao" ["algumaConstrucao" "b"] ["algumaConstrucao" "a"]) retorna "b"
 (struct tree (val right left))
 (match (tree (10 'right 'left)) [(tree a _ _) (+ 1 a)]) retorna 11
 (match "apple" [(regexp #rx"p+") #t] [_ #f])  retorna #t
\end{frame}

% --- possivelmente falar de regex, provavelmente não


% ---

\begin{frame}{Suporte à construção de compiladores}
PEG
(require peg/peg)
(define-peg number
            (name value (+ (range #\0 #\9)))
            (string->number value))
(define-peg prod
            (and (name v1 number) (? (and #\* (name v2 prod))))
            (if v2 (* v1 v2) v1))
(define-peg expr
            (and (name term1 prod) (? (and #\+ (name term2 expr))) )
            (if term2 (+ term1 term2) term1))
 (peg expr "2+4*7+6*5")     retorna 60
\end{frame}

% ---


\begin{frame}{Suporte à construção de compiladores}
PEG
(require peg/peg)
(define-peg number
            (name value (+ (range #\0 #\9)))
            (string->number value))
(define-peg var
            (and (or (range #\a #\z) (range #\A #\Z)) (* (any-char))))

(define-peg atribuicao
            (and (name variable var) "=" (name value number)) value)
(peg atribuicao "umInteiro=345") retorna 345
\end{frame}

% ---


\begin{frame}{Suporte à construção de compiladores}
PEG
(require peg/peg)
(struct soma (a b))
(struct prod (c d))
(define-peg number
            (name value (+ (range #\0 #\9)))
            (string->number value))
(define-peg prod
            (and (name v1 number) (? (and #\* (name v2 prod))))
            (if v2 (prod v1 v2) v1))
(define-peg expr
            (and (name term1 prod) (? (and #\+ (name term2 expr))) )
            (if term2 (soma term1 term2) term1))
 (soma? (peg expr "2+4*7+6*5"))     retorna #t
 (soma-a (peg expr "2+4*7+6*5"))    retorna 2
 (soma-b (peg expr "2+4*7+6*5"))    retorna #<soma>
 (soma-a (soma-b (peg expr "2+4*7+6*5"))) retorna #<prod>
 (prod-c (soma-a (soma-b (peg expr "2+4*7+6*5"))))  retorna 4
\end{frame}

% ---

\begin{frame}{Prós e Contras}

\end{frame}

\end{document}
